# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.31
#
# Don't modify this file, modify the SWIG interface instead.

package beagle;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package beaglec;
bootstrap beagle;
package beagle;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package beagle;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package beagle;

*new_intp = *beaglec::new_intp;
*copy_intp = *beaglec::copy_intp;
*delete_intp = *beaglec::delete_intp;
*intp_assign = *beaglec::intp_assign;
*intp_value = *beaglec::intp_value;
*new_doublep = *beaglec::new_doublep;
*copy_doublep = *beaglec::copy_doublep;
*delete_doublep = *beaglec::delete_doublep;
*doublep_assign = *beaglec::doublep_assign;
*doublep_value = *beaglec::doublep_value;
*new_intArray = *beaglec::new_intArray;
*delete_intArray = *beaglec::delete_intArray;
*intArray_getitem = *beaglec::intArray_getitem;
*intArray_setitem = *beaglec::intArray_setitem;
*new_doubleArray = *beaglec::new_doubleArray;
*delete_doubleArray = *beaglec::delete_doubleArray;
*doubleArray_getitem = *beaglec::doubleArray_getitem;
*doubleArray_setitem = *beaglec::doubleArray_setitem;
*beagleGetResourceList = *beaglec::beagleGetResourceList;
*beagleCreateInstance = *beaglec::beagleCreateInstance;
*beagleFinalizeInstance = *beaglec::beagleFinalizeInstance;
*beagleFinalize = *beaglec::beagleFinalize;
*beagleSetTipStates = *beaglec::beagleSetTipStates;
*beagleSetTipPartials = *beaglec::beagleSetTipPartials;
*beagleSetPartials = *beaglec::beagleSetPartials;
*beagleGetPartials = *beaglec::beagleGetPartials;
*beagleSetEigenDecomposition = *beaglec::beagleSetEigenDecomposition;
*beagleSetStateFrequencies = *beaglec::beagleSetStateFrequencies;
*beagleSetCategoryWeights = *beaglec::beagleSetCategoryWeights;
*beagleSetCategoryRates = *beaglec::beagleSetCategoryRates;
*beagleSetPatternWeights = *beaglec::beagleSetPatternWeights;
*beagleUpdateTransitionMatrices = *beaglec::beagleUpdateTransitionMatrices;
*beagleSetTransitionMatrix = *beaglec::beagleSetTransitionMatrix;
*beagleGetTransitionMatrix = *beaglec::beagleGetTransitionMatrix;
*beagleSetTransitionMatrices = *beaglec::beagleSetTransitionMatrices;
*beagleUpdatePartials = *beaglec::beagleUpdatePartials;
*beagleWaitForPartials = *beaglec::beagleWaitForPartials;
*beagleAccumulateScaleFactors = *beaglec::beagleAccumulateScaleFactors;
*beagleRemoveScaleFactors = *beaglec::beagleRemoveScaleFactors;
*beagleResetScaleFactors = *beaglec::beagleResetScaleFactors;
*beagleCopyScaleFactors = *beaglec::beagleCopyScaleFactors;
*beagleCalculateRootLogLikelihoods = *beaglec::beagleCalculateRootLogLikelihoods;
*beagleCalculateEdgeLogLikelihoods = *beaglec::beagleCalculateEdgeLogLikelihoods;
*beagleGetSiteLogLikelihoods = *beaglec::beagleGetSiteLogLikelihoods;
*beagleGetSiteDerivatives = *beaglec::beagleGetSiteDerivatives;
*new_BeagleOperationArray = *beaglec::new_BeagleOperationArray;
*delete_BeagleOperationArray = *beaglec::delete_BeagleOperationArray;
*BeagleOperationArray_getitem = *beaglec::BeagleOperationArray_getitem;
*BeagleOperationArray_setitem = *beaglec::BeagleOperationArray_setitem;

############# Class : beagle::BeagleInstanceDetails ##############

package beagle::BeagleInstanceDetails;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( beagle );
%OWNER = ();
%ITERATORS = ();
*swig_resourceNumber_get = *beaglec::BeagleInstanceDetails_resourceNumber_get;
*swig_resourceNumber_set = *beaglec::BeagleInstanceDetails_resourceNumber_set;
*swig_resourceName_get = *beaglec::BeagleInstanceDetails_resourceName_get;
*swig_resourceName_set = *beaglec::BeagleInstanceDetails_resourceName_set;
*swig_implName_get = *beaglec::BeagleInstanceDetails_implName_get;
*swig_implName_set = *beaglec::BeagleInstanceDetails_implName_set;
*swig_implDescription_get = *beaglec::BeagleInstanceDetails_implDescription_get;
*swig_implDescription_set = *beaglec::BeagleInstanceDetails_implDescription_set;
*swig_flags_get = *beaglec::BeagleInstanceDetails_flags_get;
*swig_flags_set = *beaglec::BeagleInstanceDetails_flags_set;
sub new {
    my $pkg = shift;
    my $self = beaglec::new_BeagleInstanceDetails(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        beaglec::delete_BeagleInstanceDetails($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : beagle::BeagleResource ##############

package beagle::BeagleResource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( beagle );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *beaglec::BeagleResource_name_get;
*swig_name_set = *beaglec::BeagleResource_name_set;
*swig_description_get = *beaglec::BeagleResource_description_get;
*swig_description_set = *beaglec::BeagleResource_description_set;
*swig_supportFlags_get = *beaglec::BeagleResource_supportFlags_get;
*swig_supportFlags_set = *beaglec::BeagleResource_supportFlags_set;
*swig_requiredFlags_get = *beaglec::BeagleResource_requiredFlags_get;
*swig_requiredFlags_set = *beaglec::BeagleResource_requiredFlags_set;
sub new {
    my $pkg = shift;
    my $self = beaglec::new_BeagleResource(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        beaglec::delete_BeagleResource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : beagle::BeagleResourceList ##############

package beagle::BeagleResourceList;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( beagle );
%OWNER = ();
%ITERATORS = ();
*swig_list_get = *beaglec::BeagleResourceList_list_get;
*swig_list_set = *beaglec::BeagleResourceList_list_set;
*swig_length_get = *beaglec::BeagleResourceList_length_get;
*swig_length_set = *beaglec::BeagleResourceList_length_set;
sub new {
    my $pkg = shift;
    my $self = beaglec::new_BeagleResourceList(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        beaglec::delete_BeagleResourceList($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : beagle::BeagleOperation ##############

package beagle::BeagleOperation;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( beagle );
%OWNER = ();
%ITERATORS = ();
*swig_destinationPartials_get = *beaglec::BeagleOperation_destinationPartials_get;
*swig_destinationPartials_set = *beaglec::BeagleOperation_destinationPartials_set;
*swig_destinationScaleWrite_get = *beaglec::BeagleOperation_destinationScaleWrite_get;
*swig_destinationScaleWrite_set = *beaglec::BeagleOperation_destinationScaleWrite_set;
*swig_destinationScaleRead_get = *beaglec::BeagleOperation_destinationScaleRead_get;
*swig_destinationScaleRead_set = *beaglec::BeagleOperation_destinationScaleRead_set;
*swig_child1Partials_get = *beaglec::BeagleOperation_child1Partials_get;
*swig_child1Partials_set = *beaglec::BeagleOperation_child1Partials_set;
*swig_child1TransitionMatrix_get = *beaglec::BeagleOperation_child1TransitionMatrix_get;
*swig_child1TransitionMatrix_set = *beaglec::BeagleOperation_child1TransitionMatrix_set;
*swig_child2Partials_get = *beaglec::BeagleOperation_child2Partials_get;
*swig_child2Partials_set = *beaglec::BeagleOperation_child2Partials_set;
*swig_child2TransitionMatrix_get = *beaglec::BeagleOperation_child2TransitionMatrix_get;
*swig_child2TransitionMatrix_set = *beaglec::BeagleOperation_child2TransitionMatrix_set;
sub new {
    my $pkg = shift;
    my $self = beaglec::new_BeagleOperation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        beaglec::delete_BeagleOperation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package beagle;

*BEAGLE_SUCCESS = *beaglec::BEAGLE_SUCCESS;
*BEAGLE_ERROR_GENERAL = *beaglec::BEAGLE_ERROR_GENERAL;
*BEAGLE_ERROR_OUT_OF_MEMORY = *beaglec::BEAGLE_ERROR_OUT_OF_MEMORY;
*BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION = *beaglec::BEAGLE_ERROR_UNIDENTIFIED_EXCEPTION;
*BEAGLE_ERROR_UNINITIALIZED_INSTANCE = *beaglec::BEAGLE_ERROR_UNINITIALIZED_INSTANCE;
*BEAGLE_ERROR_OUT_OF_RANGE = *beaglec::BEAGLE_ERROR_OUT_OF_RANGE;
*BEAGLE_ERROR_NO_RESOURCE = *beaglec::BEAGLE_ERROR_NO_RESOURCE;
*BEAGLE_ERROR_NO_IMPLEMENTATION = *beaglec::BEAGLE_ERROR_NO_IMPLEMENTATION;
*BEAGLE_ERROR_FLOATING_POINT = *beaglec::BEAGLE_ERROR_FLOATING_POINT;
*BEAGLE_FLAG_PRECISION_SINGLE = *beaglec::BEAGLE_FLAG_PRECISION_SINGLE;
*BEAGLE_FLAG_PRECISION_DOUBLE = *beaglec::BEAGLE_FLAG_PRECISION_DOUBLE;
*BEAGLE_FLAG_COMPUTATION_SYNCH = *beaglec::BEAGLE_FLAG_COMPUTATION_SYNCH;
*BEAGLE_FLAG_COMPUTATION_ASYNCH = *beaglec::BEAGLE_FLAG_COMPUTATION_ASYNCH;
*BEAGLE_FLAG_EIGEN_REAL = *beaglec::BEAGLE_FLAG_EIGEN_REAL;
*BEAGLE_FLAG_EIGEN_COMPLEX = *beaglec::BEAGLE_FLAG_EIGEN_COMPLEX;
*BEAGLE_FLAG_SCALING_MANUAL = *beaglec::BEAGLE_FLAG_SCALING_MANUAL;
*BEAGLE_FLAG_SCALING_AUTO = *beaglec::BEAGLE_FLAG_SCALING_AUTO;
*BEAGLE_FLAG_SCALING_ALWAYS = *beaglec::BEAGLE_FLAG_SCALING_ALWAYS;
*BEAGLE_FLAG_SCALING_DYNAMIC = *beaglec::BEAGLE_FLAG_SCALING_DYNAMIC;
*BEAGLE_FLAG_SCALERS_RAW = *beaglec::BEAGLE_FLAG_SCALERS_RAW;
*BEAGLE_FLAG_SCALERS_LOG = *beaglec::BEAGLE_FLAG_SCALERS_LOG;
*BEAGLE_FLAG_INVEVEC_STANDARD = *beaglec::BEAGLE_FLAG_INVEVEC_STANDARD;
*BEAGLE_FLAG_INVEVEC_TRANSPOSED = *beaglec::BEAGLE_FLAG_INVEVEC_TRANSPOSED;
*BEAGLE_FLAG_VECTOR_SSE = *beaglec::BEAGLE_FLAG_VECTOR_SSE;
*BEAGLE_FLAG_VECTOR_NONE = *beaglec::BEAGLE_FLAG_VECTOR_NONE;
*BEAGLE_FLAG_THREADING_OPENMP = *beaglec::BEAGLE_FLAG_THREADING_OPENMP;
*BEAGLE_FLAG_THREADING_NONE = *beaglec::BEAGLE_FLAG_THREADING_NONE;
*BEAGLE_FLAG_PROCESSOR_CPU = *beaglec::BEAGLE_FLAG_PROCESSOR_CPU;
*BEAGLE_FLAG_PROCESSOR_GPU = *beaglec::BEAGLE_FLAG_PROCESSOR_GPU;
*BEAGLE_FLAG_PROCESSOR_FPGA = *beaglec::BEAGLE_FLAG_PROCESSOR_FPGA;
*BEAGLE_FLAG_PROCESSOR_CELL = *beaglec::BEAGLE_FLAG_PROCESSOR_CELL;
*BEAGLE_FLAG_FRAMEWORK_CUDA = *beaglec::BEAGLE_FLAG_FRAMEWORK_CUDA;
*BEAGLE_FLAG_FRAMEWORK_OPENCL = *beaglec::BEAGLE_FLAG_FRAMEWORK_OPENCL;
*BEAGLE_OP_COUNT = *beaglec::BEAGLE_OP_COUNT;
*BEAGLE_OP_NONE = *beaglec::BEAGLE_OP_NONE;
1;
